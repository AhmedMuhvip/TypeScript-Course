"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const architect_1 = require("@angular-devkit/architect");
const rxjs_1 = require("rxjs");
const shell = require("shelljs");
const copy_1 = require("../helpers/copy");
let buildFunc = architect_1.createBuilder((options, context) => {
    let observable = new rxjs_1.Observable((observer) => {
        try {
            concurrentlyRun(context, options).then(() => {
                // copying things that need copying
                copy_1.copyArray(options.copy);
                observer.next({ success: true });
            });
        }
        catch (err) {
            observer.next({ success: false });
            observer.complete();
        }
    });
    return observable;
});
exports.default = buildFunc;
function concurrentlyRun(context, options) {
    return __awaiter(this, void 0, void 0, function* () {
        // setting the node env option by default it's production 
        let NODE_ENV = options.NODE_ENV || 'development';
        let inspectWithPort = options.debugPort === undefined ? '--inspect' : `--inspect=${options.debugPort}`;
        let debug = options.debug === undefined || options.debug === false ? '' : inspectWithPort;
        let tscBuild = shell.exec(`tsc --build ${context.currentDirectory}/${options.tsconfig} --pretty --watch`, { async: true });
        tscBuild.stdout.on('data', (chunk) => {
            // string that the typescript compilation has succeeded 
            let result = chunk.indexOf(`Found 0 errors. Watching for file changes.`);
            if (result !== -1) {
                // compilation succeded time to run node process
                shell.exec(`NODE_ENV=${NODE_ENV} nodemon --signal SIGINT ${getWatchFilesString(options)} ${debug}  --delay ${options.delayBetweenRestarts || 1.5} -r tsconfig-paths/register -r ts-node/register ${context.currentDirectory}/${options.mainInOutput}`, {
                    async: true
                });
            }
        });
    });
}
/**
 * @description this will receive the options and return a string of the files needs to be watched
 * @param context
 * @param options
 */
let getWatchFilesString = (options) => {
    let watchArgs = '';
    if (options.watch.length !== 0)
        return `--watch ${options.watch.join(' --watch ')}`;
    return watchArgs;
};
//# sourceMappingURL=index.js.map