"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const architect_1 = require("@angular-devkit/architect");
const childProcess = require("child_process");
const rimraf = require("rimraf");
const rxjs_1 = require("rxjs");
const copy_1 = require("../helpers/copy");
let buildFunc = architect_1.createBuilder((options, context) => {
    if (options.clean) {
        options.clean.forEach(dir => rimraf.sync(`${context.currentDirectory}/${dir}`));
    }
    let runAndBuild = options.runAndBuild === undefined || options.runAndBuild === false ? false : true;
    let buildPromise = buildOnlyMode(context, options);
    if (!runAndBuild) {
        // copying things that need copying
        buildPromise.then(() => copy_1.copyArray(options.copy));
        return buildPromise;
    }
    let observable = new rxjs_1.Observable((observer) => {
        buildPromise.then(({ success }) => {
            // copying things that need copying
            copy_1.copyArray(options.copy);
            // only run the node server if the build was successfull
            if (success) {
                let pid = runNodeServer(context, options);
                if (pid !== undefined)
                    return observer.next({ success: true });
                return observer.next({ success: false });
            }
            // end the observer and publish that it was not successful
            if (!success) {
                observer.next({ success: false });
                observer.complete();
            }
        });
    });
    return observable;
});
exports.default = buildFunc;
function runNodeServer(context, options) {
    // setting the node env option by default it's production 
    let NODE_ENV = options.NODE_ENV || 'production';
    let child = childProcess.spawn('env', [
        `NODE_ENV=${NODE_ENV}`,
        'node',
        '-r',
        'tsconfig-paths/register',
        '-r',
        'ts-node/register',
        `${context.currentDirectory}/${options.mainInOutput}`
    ], { stdio: 'pipe' });
    child.stdout.on('data', (data) => context.logger.info(Buffer.from(data).toString('utf8')));
    child.stderr.on('data', (data) => child.stdout.emit('data', data));
    return child.pid;
}
function buildOnlyMode(context, options) {
    return __awaiter(this, void 0, void 0, function* () {
        let tscResult = spawnTSC(context, options);
        context.logger.info(Buffer.from(tscResult.stdout).toString('utf8'));
        if (tscResult.status === 0) {
            context.logger.info('Typescript compiled successfully');
        }
        return { success: tscResult.status === 0 };
    });
}
function spawnTSC(context, options) {
    return childProcess.spawnSync('tsc', [
        '--build', `${context.currentDirectory}/${options.tsconfig}`,
        '--pretty'
    ]);
}
//# sourceMappingURL=index.js.map