"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const architect_1 = require("@angular-devkit/architect");
const testing_1 = require("@angular-devkit/architect/testing");
const core_1 = require("@angular-devkit/core");
const fs = require("fs");
const { join } = require('path');
describe('Command Runner Builder', () => {
    let architect;
    let architectHost;
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        const registry = new core_1.schema.CoreSchemaRegistry();
        registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
        // Arguments to TestingArchitectHost are workspace and current directories.
        // Since we don't use those, both are the same in this case.
        architectHost = new testing_1.TestingArchitectHost(__dirname, __dirname);
        architect = new architect_1.Architect(architectHost, registry);
        // This will either take a Node package name, or a path to the directory
        // for the package.json file.
        yield architectHost.addBuilderFromPackage(join(__dirname, '..'));
        console.log('#', Array.from(architectHost._builderMap.keys()));
        jasmine.DEFAULT_TIMEOUT_INTERVAL = (1000 * 60) * 2; // 1 min
    }));
    it('should build the project successfully', () => __awaiter(void 0, void 0, void 0, function* () {
        // Create a logger that keeps an array of all messages that were logged.
        const logger = new core_1.logging.Logger('');
        let logs = [];
        logger.subscribe(ev => logs.push(ev.message));
        let options = {
            mainInOutput: 'testapp/dist/test.js',
            tsconfig: 'testapp/tsconfig.json',
            runAndBuild: false,
            NODE_ENV: 'production',
            copy: [
                { from: './build/testapp/', to: './testos/' }
            ],
            clean: []
        };
        // A "run" can contain multiple outputs, and contains progress information.
        const run = yield architect.scheduleBuilder('ts-node-builder:build', options, { logger }); // We pass the logger for checking later.
        // The "result" member is the next output of the runner.
        // This is of type BuilderOutput.
        let output = yield run.result;
        // Stop the builder from running. This really stops Architect from keeping
        // the builder associated states in memory, since builders keep waiting
        // to be scheduled.
        yield run.stop();
        // Expect that it succeeded.
        expect(output.success).toBe(true);
        // Expect that this file was listed. It should be since we're running
        // `ls $__dirname`.
        expect(logs.toString()).toContain('Typescript compiled successfully');
        options = {
            mainInOutput: 'testapp/dist/test.js',
            tsconfig: 'testapp/tsconfig.json',
            runAndBuild: false,
            NODE_ENV: 'production',
            copy: [],
            clean: [
                'testapp/dist'
            ]
        };
        // A "run" can contain multiple outputs, and contains progress information.
        const cleanRun = yield architect.scheduleBuilder('ts-node-builder:build', options, { logger }); // We pass the logger for checking later.
        // The "result" member is the next output of the runner.
        // This is of type BuilderOutput.
        let cleanOutput = yield cleanRun.result;
        // Stop the builder from running. This really stops Architect from keeping
        // the builder associated states in memory, since builders keep waiting
        // to be scheduled.
        yield cleanRun.stop();
        // Expect that it succeeded.
        expect(cleanOutput.success).toBe(true);
        // Since the directory was cleared and testos was not copied the second run, it should not exist
        expect(fs.existsSync(join(__dirname, 'testapp/dist/testos'))).toBe(false);
        // Expect that this file was listed. It should be since we're running
        // `ls $__dirname`.
        expect(logs.toString()).toContain('Typescript compiled successfully');
    }));
    it('should build and run successfully', () => __awaiter(void 0, void 0, void 0, function* () {
        // Create a logger that keeps an array of all messages that were logged.
        const logger = new core_1.logging.Logger('');
        const logs = [];
        logger.subscribe(ev => logs.push(ev.message));
        let options = {
            mainInOutput: 'testapp/dist/test.js',
            tsconfig: 'testapp/tsconfig.json',
            runAndBuild: true,
            NODE_ENV: 'production',
            copy: [
                { from: './build/testapp/', to: './testos/' }
            ],
            clean: []
        };
        // A "run" can contain multiple outputs, and contains progress information.
        const run = yield architect.scheduleBuilder('ts-node-builder:build', options, { logger }); // We pass the logger for checking later.
        // The "result" member is the next output of the runner.
        // This is of type BuilderOutput.
        yield run.result;
        // Stop the builder from running. This really stops Architect from keeping
        // the builder associated states in memory, since builders keep waiting
        // to be scheduled.
        yield run.stop();
    }));
});
//# sourceMappingURL=index_spec.js.map